<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>ğŸ€ GosÃ³weczki Karolinki ğŸ€</title>
<style>
body {
  background: linear-gradient(180deg, #ffd6ec, #ffe5f3);
  font-family: "SF Pro Rounded", "Helvetica Neue", sans-serif;
  color: #333;
  text-align: center;
  padding: 30px;
}
h1 {
  color: #ff4fa3;
  margin-bottom: 20px;
  font-weight: 600;
}
button {
  background: #ff7fc0;
  border: none;
  color: white;
  padding: 10px 18px;
  border-radius: 12px;
  cursor: pointer;
  margin: 6px;
  font-size: 16px;
  transition: 0.2s;
}
button:hover {
  background: #ff5caa;
  transform: scale(1.05);
}
#segments {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 15px;
  margin-top: 20px;
}
.segment {
  background: white;
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  border-radius: 15px;
  width: 180px;
  padding: 12px;
  transition: 0.3s;
}
.segment.dragging {
  opacity: 0.5;
}
.segment:hover {
  transform: translateY(-3px);
}
.segment input {
  border: none;
  text-align: center;
  font-weight: bold;
  color: #ff4fa3;
  font-size: 15px;
  width: 100%;
}
.audio-controls {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-top: 8px;
}
</style>
</head>
<body>

<h1>ğŸ€ GosÃ³weczki Karolinki ğŸ€</h1>

<div>
  <button id="startRec">ğŸ™ï¸ Nagrywaj segment</button>
  <button id="stopRec" disabled>â¹ï¸ Stop</button>
  <button id="mergeBtn">ğŸ”— PoÅ‚Ä…cz segmenty</button>
  <select id="formatSelect">
    <option value="wav">WAV</option>
    <option value="ogg">OGG</option>
    <option value="webm">WEBM</option>
  </select>
  <button id="exportBtn" disabled>ğŸ’¾ Eksportuj</button>
</div>

<div id="segments"></div>

<script>
let mediaRecorder;
let chunks = [];
let recordings = [];
let isRecording = false;

const startBtn = document.getElementById('startRec');
const stopBtn = document.getElementById('stopRec');
const mergeBtn = document.getElementById('mergeBtn');
const exportBtn = document.getElementById('exportBtn');
const container = document.getElementById('segments');
const formatSelect = document.getElementById('formatSelect');

async function startRecording() {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream);
  chunks = [];

  mediaRecorder.ondataavailable = e => chunks.push(e.data);
  mediaRecorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    addSegment(blob);
  };

  mediaRecorder.start();
  isRecording = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
}

function stopRecording() {
  mediaRecorder.stop();
  isRecording = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

function addSegment(blob) {
  const index = recordings.length + 1;
  const segment = document.createElement('div');
  segment.className = 'segment';
  segment.draggable = true;

  const nameInput = document.createElement('input');
  nameInput.value = `Segment ${index}`;

  const audio = document.createElement('audio');
  audio.controls = true;
  audio.src = URL.createObjectURL(blob);

  const delBtn = document.createElement('button');
  delBtn.textContent = 'ğŸ—‘ï¸';
  delBtn.onclick = () => {
    recordings = recordings.filter(r => r.div !== segment);
    segment.remove();
  };

  const controls = document.createElement('div');
  controls.className = 'audio-controls';
  controls.appendChild(delBtn);

  segment.appendChild(nameInput);
  segment.appendChild(audio);
  segment.appendChild(controls);

  container.appendChild(segment);
  recordings.push({ blob, div: segment, nameInput });

  enableDragAndDrop();
}

function enableDragAndDrop() {
  const segs = document.querySelectorAll('.segment');
  segs.forEach(seg => {
    seg.addEventListener('dragstart', () => seg.classList.add('dragging'));
    seg.addEventListener('dragend', () => seg.classList.remove('dragging'));
  });
  container.addEventListener('dragover', e => {
    e.preventDefault();
    const dragging = document.querySelector('.dragging');
    const after = getDragAfterElement(container, e.clientY);
    if (after == null) container.appendChild(dragging);
    else container.insertBefore(dragging, after);
  });
}

function getDragAfterElement(container, y) {
  const els = [...container.querySelectorAll('.segment:not(.dragging)')];
  return els.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset)
      return { offset: offset, element: child };
    else
      return closest;
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

async function mergeSegments() {
  if (recordings.length === 0) return alert("Brak segmentÃ³w!");
  const ordered = [...container.querySelectorAll('.segment')];
  const orderedBlobs = ordered.map(div =>
    recordings.find(r => r.div === div).blob
  );

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const decoded = await Promise.all(
    orderedBlobs.map(b => b.arrayBuffer().then(ab => audioCtx.decodeAudioData(ab)))
  );

  // PoÅ‚Ä…cz Å›cieÅ¼ki
  let totalLength = decoded.reduce((acc, b) => acc + b.length, 0);
  let output = audioCtx.createBuffer(1, totalLength, audioCtx.sampleRate);
  let offset = 0;
  decoded.forEach(b => {
    output.getChannelData(0).set(b.getChannelData(0), offset);
    offset += b.length;
  });

  // Zapis jako WAV
  const merged = audioBufferToWav(output);
  mergedBlob = new Blob([merged], { type: 'audio/wav' });
  exportBtn.disabled = false;
  alert("âœ… PoÅ‚Ä…czono segmenty!");
}

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels,
    length = buffer.length * numOfChan * 2 + 44,
    bufferOut = new ArrayBuffer(length),
    view = new DataView(bufferOut),
    channels = [],
    sampleRate = buffer.sampleRate;
  let offset = 0;
  function writeString(s) { for (let i = 0; i < s.length; i++) view.setUint8(offset + i, s.charCodeAt(i)); offset += s.length; }
  writeString('RIFF'); view.setUint32(4, 36 + buffer.length * 2, true);
  writeString('WAVEfmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true); view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true); view.setUint16(32, numOfChan * 2, true);
  view.setUint16(34, 16, true); writeString('data'); view.setUint32(40, buffer.length * 2, true);
  for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));
  let idx = 44;
  for (let i = 0; i < buffer.length; i++) {
    for (let c = 0; c < numOfChan; c++) {
      let sample = Math.max(-1, Math.min(1, channels[c][i]));
      view.setInt16(idx, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
      idx += 2;
    }
  }
  return bufferOut;
}

let mergedBlob = null;
function exportAudio() {
  if (!mergedBlob) return;
  const format = formatSelect.value;
  let mime = 'audio/wav';
  if (format === 'ogg') mime = 'audio/ogg';
  if (format === 'webm') mime = 'audio/webm';
  const file = new Blob([mergedBlob], { type: mime });
  const url = URL.createObjectURL(file);
  const a = document.createElement('a');
  a.href = url;
  a.download = `export.${format}`;
  a.click();
  URL.revokeObjectURL(url);
}

startBtn.onclick = startRecording;
stopBtn.onclick = stopRecording;
mergeBtn.onclick = mergeSegments;
exportBtn.onclick = exportAudio;
</script>

</body>
</html>
